# ⚙️ **AutoLang Type Checker Documentation**

## **1. Introduction**

The **Type Checker** is the third stage in the AutoLang compilation pipeline, following the **Lexer** and **Parser**.

Its primary responsibility is to ensure **semantic correctness** by verifying that all operations, assignments, and expressions in an AutoLang program respect **type compatibility rules**.

By enforcing strong type checking, the system ensures **safe and predictable execution** in **real-time automotive environments**, where type-related runtime errors can lead to critical failures.

---

## **2. Objectives**

The **Type Checker** for AutoLang aims to:

1. Verify that every variable is declared before use.
2. Ensure that assigned expressions match the declared type of the variable.
3. Enforce correct operand types for arithmetic (`+`, `-`) and comparison (`>`, `==`) operations.
4. Report **semantic errors** with line numbers and descriptive messages.
5. Guarantee type safety before code generation or execution.

---

## **3. Role in Compiler Pipeline**

```
Source Code  →  Lexer  →  Parser  →  AST  →  Type Checker  →  Code Generator
```

| Stage            | Input    | Output                          |
| ---------------- | -------- | ------------------------------- |
| **Lexer**        | Raw text | Tokens                          |
| **Parser**       | Tokens   | Abstract Syntax Tree (AST)      |
| **Type Checker** | AST      | Type-validated AST / Error list |

---

## **4. Input and Output**

### **Input:**

* Abstract Syntax Tree (AST) generated by the Parser.

### **Output:**

* Annotated AST with verified types (or)
* List of **semantic error messages** such as:

  * `Line 6: Undeclared variable 'speed'`
  * `Line 8: Type mismatch: expected float but found bool`
  * `Line 10: Invalid comparison between int and bool`

---

## **5. Supported Types and Rules**

AutoLang supports three primitive types:

| Type    | Description               | Example                |
| ------- | ------------------------- | ---------------------- |
| `int`   | Integer numeric value     | `rpm`, `100`           |
| `float` | Real number with decimals | `speed`, `60.5`        |
| `bool`  | Logical true/false        | `brakePressed`, `true` |

### **Type Rules Summary**

| Operation | Allowed Types                                                        | Result Type      | Example                |
| --------- | -------------------------------------------------------------------- | ---------------- | ---------------------- |
| `+`, `-`  | `int + int`, `float + float`, `int + float` (coercion to float)      | `int` or `float` | `speed - 5.0`          |
| `>`       | Numeric types only (`int`, `float`)                                  | `bool`           | `speed > 60.0`         |
| `==`      | Any two matching types                                               | `bool`           | `brakePressed == true` |
| `set`     | Variable and expression types must match (or allow numeric widening) | Variable type    | `set speed 50.0;`      |

---

## **6. Type Environment (Symbol Table)**

The Type Checker maintains a **symbol table** that records declared identifiers and their associated types.
It is implemented as a map:

```cpp
std::unordered_map<std::string, std::string> symbolTable;
```

### Example:

After parsing:

```autolang
float speed;
int rpm;
bool brakePressed;
```

Symbol table contents:

```
speed → float
rpm → int
brakePressed → bool
```

---

## **7. Type Checking Rules**

### **7.1 Declarations**

* A variable can only be declared once per control block.
* The declared type is stored in the symbol table.

**Error Example:**

```
Line 3: Variable 'speed' already declared
```

---

### **7.2 Assignments (set statements)**

* The type of the right-hand side expression must match the declared type of the variable.
* Implicit numeric widening (`int` → `float`) is allowed.
* No implicit conversion between `bool` and numeric types.

**Examples:**
✅ `float speed; set speed 80.5;`
❌ `bool brake; set brake 50;  // Type mismatch`

---

### **7.3 Expressions**

The checker recursively validates the operands and operator types in expressions.

| Expression Type   | Rule                                        | Result Type                                   |
| ----------------- | ------------------------------------------- | --------------------------------------------- |
| Arithmetic (+, -) | Operands must be numeric (`int` or `float`) | `float` if any operand is `float`, else `int` |
| Comparison (>)    | Both operands must be numeric               | `bool`                                        |
| Equality (==)     | Both operands must be of the same type      | `bool`                                        |

**Error Example:**

```
Line 10: Invalid operand types for '+': float and bool
```

---

### **7.4 If Conditions**

* The condition inside an `if` must evaluate to a `bool` type.
* The statements inside `{}` are checked recursively in a new scope.

**Error Example:**

```
Line 7: Condition must be of type bool, found float
```

---

### **7.5 Undeclared Variables**

* Using an undeclared variable before its declaration is invalid.

**Error Example:**

```
Line 4: Undeclared variable 'rpm'
```

---

## **8. Example Walkthrough**

### **Program:**

```autolang
control speedControl {
    float speed;
    int rpm;
    bool brakePressed;

    set speed 80.5;
    set rpm speed;  // Error
    if (brakePressed == true) {
        set speed speed - 10.5;
    }
}
```

### **Step 1: Symbol Table Creation**

```
speed → float
rpm → int
brakePressed → bool
```

### **Step 2: Type Checking**

| Statement                   | Check               | Result          |
| --------------------------- | ------------------- | --------------- |
| `set speed 80.5`            | float ← float       | ✅               |
| `set rpm speed`             | int ← float         | ❌ Type mismatch |
| `if (brakePressed == true)` | bool == bool → bool | ✅               |
| `set speed speed - 10.5`    | float ← float       | ✅               |

### **Output Errors:**

```
Line 7: Type mismatch: expected int but found float
```

---

## **9. Type Checker Architecture**

### **Core Components**

| Component         | Description                                  |
| ----------------- | -------------------------------------------- |
| **SymbolTable**   | Stores variable declarations and types       |
| **TypeChecker**   | Traverses AST nodes and validates types      |
| **ErrorReporter** | Collects and prints semantic error messages  |
| **Node Visitors** | Visit each AST node and infer/validate types |

---

## **10. Type Checking Functions**

| Function                     | Purpose                                             |
| ---------------------------- | --------------------------------------------------- |
| `checkProgram(node)`         | Traverse all control blocks                         |
| `checkControlBlock(node)`    | Initialize new symbol table scope                   |
| `checkDeclaration(node)`     | Register variable and type                          |
| `checkAssignment(node)`      | Validate type consistency of `set` statements       |
| `checkIf(node)`              | Ensure condition is `bool`; recursively check body  |
| `inferExpressionType(node)`  | Return the type of an expression (int, float, bool) |
| `reportError(line, message)` | Record and display semantic errors                  |

---

## **11. Error Reporting Format**

Each semantic error is reported with:

```
Line X: <error message>
```

**Examples:**

```
Line 8: Type mismatch: expected int but found float
Line 11: Condition must be of type bool
Line 5: Variable 'rpm' redeclared
```

---

## **12. Example Output (for the given program)**

```
Semantic Errors:
Line 7: Type mismatch: expected int but found float

Type Checking completed with 1 error(s).
```

If no errors are found:

```
Type Checking completed successfully.
```

---

## **13. Implementation Summary**

The Type Checker operates by:

1. **Traversing the AST** recursively.
2. Maintaining a **symbol table** for each control block.
3. **Inferring expression types** dynamically.
4. Validating **type rules** for every statement.
5. Reporting **semantic errors** with precise line context.


---

## **14. Conclusion**

The **AutoLang Type Checker** ensures **semantic integrity** by enforcing strict type rules across variables, expressions, and conditions.
By validating the AST before execution, it prevents type-related runtime failures in **real-time automotive systems**, improving reliability, safety, and maintainability of AutoLang programs.

